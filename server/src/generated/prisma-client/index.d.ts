// Code generated by Prisma (prisma@1.19.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  htmlMetaData: (where?: HtmlMetaDataWhereInput) => Promise<boolean>;
  productFetcher: (where?: ProductFetcherWhereInput) => Promise<boolean>;
  productObservation: (
    where?: ProductObservationWhereInput
  ) => Promise<boolean>;
  productPage: (where?: ProductPageWhereInput) => Promise<boolean>;
  relatedProduct: (where?: RelatedProductWhereInput) => Promise<boolean>;
  scriptMetaData: (where?: ScriptMetaDataWhereInput) => Promise<boolean>;
  similarProduct: (where?: SimilarProductWhereInput) => Promise<boolean>;
  store: (where?: StoreWhereInput) => Promise<boolean>;
  transformation: (where?: TransformationWhereInput) => Promise<boolean>;
  xhrMetaData: (where?: XhrMetaDataWhereInput) => Promise<boolean>;
  fieldMetaData: (where?: fieldMetaDataWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  htmlMetaData: (where: HtmlMetaDataWhereUniqueInput) => HtmlMetaData;
  htmlMetaDatas: (
    args?: {
      where?: HtmlMetaDataWhereInput;
      orderBy?: HtmlMetaDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<HtmlMetaDataNode>;
  htmlMetaDatasConnection: (
    args?: {
      where?: HtmlMetaDataWhereInput;
      orderBy?: HtmlMetaDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HtmlMetaDataConnection;
  productFetcher: (where: ProductFetcherWhereUniqueInput) => ProductFetcher;
  productFetchers: (
    args?: {
      where?: ProductFetcherWhereInput;
      orderBy?: ProductFetcherOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProductFetcherNode>;
  productFetchersConnection: (
    args?: {
      where?: ProductFetcherWhereInput;
      orderBy?: ProductFetcherOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductFetcherConnection;
  productObservation: (
    where: ProductObservationWhereUniqueInput
  ) => ProductObservation;
  productObservations: (
    args?: {
      where?: ProductObservationWhereInput;
      orderBy?: ProductObservationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProductObservationNode>;
  productObservationsConnection: (
    args?: {
      where?: ProductObservationWhereInput;
      orderBy?: ProductObservationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductObservationConnection;
  productPage: (where: ProductPageWhereUniqueInput) => ProductPage;
  productPages: (
    args?: {
      where?: ProductPageWhereInput;
      orderBy?: ProductPageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProductPageNode>;
  productPagesConnection: (
    args?: {
      where?: ProductPageWhereInput;
      orderBy?: ProductPageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductPageConnection;
  relatedProduct: (where: RelatedProductWhereUniqueInput) => RelatedProduct;
  relatedProducts: (
    args?: {
      where?: RelatedProductWhereInput;
      orderBy?: RelatedProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RelatedProductNode>;
  relatedProductsConnection: (
    args?: {
      where?: RelatedProductWhereInput;
      orderBy?: RelatedProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RelatedProductConnection;
  scriptMetaData: (where: ScriptMetaDataWhereUniqueInput) => ScriptMetaData;
  scriptMetaDatas: (
    args?: {
      where?: ScriptMetaDataWhereInput;
      orderBy?: ScriptMetaDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScriptMetaDataNode>;
  scriptMetaDatasConnection: (
    args?: {
      where?: ScriptMetaDataWhereInput;
      orderBy?: ScriptMetaDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScriptMetaDataConnection;
  similarProduct: (where: SimilarProductWhereUniqueInput) => SimilarProduct;
  similarProducts: (
    args?: {
      where?: SimilarProductWhereInput;
      orderBy?: SimilarProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SimilarProductNode>;
  similarProductsConnection: (
    args?: {
      where?: SimilarProductWhereInput;
      orderBy?: SimilarProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SimilarProductConnection;
  store: (where: StoreWhereUniqueInput) => Store;
  stores: (
    args?: {
      where?: StoreWhereInput;
      orderBy?: StoreOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<StoreNode>;
  storesConnection: (
    args?: {
      where?: StoreWhereInput;
      orderBy?: StoreOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StoreConnection;
  transformation: (where: TransformationWhereUniqueInput) => Transformation;
  transformations: (
    args?: {
      where?: TransformationWhereInput;
      orderBy?: TransformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TransformationNode>;
  transformationsConnection: (
    args?: {
      where?: TransformationWhereInput;
      orderBy?: TransformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TransformationConnection;
  xhrMetaData: (where: XhrMetaDataWhereUniqueInput) => XhrMetaData;
  xhrMetaDatas: (
    args?: {
      where?: XhrMetaDataWhereInput;
      orderBy?: XhrMetaDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<XhrMetaDataNode>;
  xhrMetaDatasConnection: (
    args?: {
      where?: XhrMetaDataWhereInput;
      orderBy?: XhrMetaDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => XhrMetaDataConnection;
  fieldMetaData: (where: fieldMetaDataWhereUniqueInput) => fieldMetaData;
  fieldMetaDatas: (
    args?: {
      where?: fieldMetaDataWhereInput;
      orderBy?: fieldMetaDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<fieldMetaDataNode>;
  fieldMetaDatasConnection: (
    args?: {
      where?: fieldMetaDataWhereInput;
      orderBy?: fieldMetaDataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => fieldMetaDataConnection;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createHtmlMetaData: (data: HtmlMetaDataCreateInput) => HtmlMetaData;
  updateHtmlMetaData: (
    args: { data: HtmlMetaDataUpdateInput; where: HtmlMetaDataWhereUniqueInput }
  ) => HtmlMetaData;
  updateManyHtmlMetaDatas: (
    args: { data: HtmlMetaDataUpdateInput; where?: HtmlMetaDataWhereInput }
  ) => BatchPayload;
  upsertHtmlMetaData: (
    args: {
      where: HtmlMetaDataWhereUniqueInput;
      create: HtmlMetaDataCreateInput;
      update: HtmlMetaDataUpdateInput;
    }
  ) => HtmlMetaData;
  deleteHtmlMetaData: (where: HtmlMetaDataWhereUniqueInput) => HtmlMetaData;
  deleteManyHtmlMetaDatas: (where?: HtmlMetaDataWhereInput) => BatchPayload;
  createProductFetcher: (data: ProductFetcherCreateInput) => ProductFetcher;
  updateProductFetcher: (
    args: {
      data: ProductFetcherUpdateInput;
      where: ProductFetcherWhereUniqueInput;
    }
  ) => ProductFetcher;
  updateManyProductFetchers: (
    args: { data: ProductFetcherUpdateInput; where?: ProductFetcherWhereInput }
  ) => BatchPayload;
  upsertProductFetcher: (
    args: {
      where: ProductFetcherWhereUniqueInput;
      create: ProductFetcherCreateInput;
      update: ProductFetcherUpdateInput;
    }
  ) => ProductFetcher;
  deleteProductFetcher: (
    where: ProductFetcherWhereUniqueInput
  ) => ProductFetcher;
  deleteManyProductFetchers: (where?: ProductFetcherWhereInput) => BatchPayload;
  createProductObservation: (
    data: ProductObservationCreateInput
  ) => ProductObservation;
  updateProductObservation: (
    args: {
      data: ProductObservationUpdateInput;
      where: ProductObservationWhereUniqueInput;
    }
  ) => ProductObservation;
  updateManyProductObservations: (
    args: {
      data: ProductObservationUpdateInput;
      where?: ProductObservationWhereInput;
    }
  ) => BatchPayload;
  upsertProductObservation: (
    args: {
      where: ProductObservationWhereUniqueInput;
      create: ProductObservationCreateInput;
      update: ProductObservationUpdateInput;
    }
  ) => ProductObservation;
  deleteProductObservation: (
    where: ProductObservationWhereUniqueInput
  ) => ProductObservation;
  deleteManyProductObservations: (
    where?: ProductObservationWhereInput
  ) => BatchPayload;
  createProductPage: (data: ProductPageCreateInput) => ProductPage;
  updateProductPage: (
    args: { data: ProductPageUpdateInput; where: ProductPageWhereUniqueInput }
  ) => ProductPage;
  updateManyProductPages: (
    args: { data: ProductPageUpdateInput; where?: ProductPageWhereInput }
  ) => BatchPayload;
  upsertProductPage: (
    args: {
      where: ProductPageWhereUniqueInput;
      create: ProductPageCreateInput;
      update: ProductPageUpdateInput;
    }
  ) => ProductPage;
  deleteProductPage: (where: ProductPageWhereUniqueInput) => ProductPage;
  deleteManyProductPages: (where?: ProductPageWhereInput) => BatchPayload;
  createRelatedProduct: (data: RelatedProductCreateInput) => RelatedProduct;
  updateRelatedProduct: (
    args: {
      data: RelatedProductUpdateInput;
      where: RelatedProductWhereUniqueInput;
    }
  ) => RelatedProduct;
  updateManyRelatedProducts: (
    args: { data: RelatedProductUpdateInput; where?: RelatedProductWhereInput }
  ) => BatchPayload;
  upsertRelatedProduct: (
    args: {
      where: RelatedProductWhereUniqueInput;
      create: RelatedProductCreateInput;
      update: RelatedProductUpdateInput;
    }
  ) => RelatedProduct;
  deleteRelatedProduct: (
    where: RelatedProductWhereUniqueInput
  ) => RelatedProduct;
  deleteManyRelatedProducts: (where?: RelatedProductWhereInput) => BatchPayload;
  createScriptMetaData: (data: ScriptMetaDataCreateInput) => ScriptMetaData;
  updateScriptMetaData: (
    args: {
      data: ScriptMetaDataUpdateInput;
      where: ScriptMetaDataWhereUniqueInput;
    }
  ) => ScriptMetaData;
  updateManyScriptMetaDatas: (
    args: { data: ScriptMetaDataUpdateInput; where?: ScriptMetaDataWhereInput }
  ) => BatchPayload;
  upsertScriptMetaData: (
    args: {
      where: ScriptMetaDataWhereUniqueInput;
      create: ScriptMetaDataCreateInput;
      update: ScriptMetaDataUpdateInput;
    }
  ) => ScriptMetaData;
  deleteScriptMetaData: (
    where: ScriptMetaDataWhereUniqueInput
  ) => ScriptMetaData;
  deleteManyScriptMetaDatas: (where?: ScriptMetaDataWhereInput) => BatchPayload;
  createSimilarProduct: (data: SimilarProductCreateInput) => SimilarProduct;
  updateSimilarProduct: (
    args: {
      data: SimilarProductUpdateInput;
      where: SimilarProductWhereUniqueInput;
    }
  ) => SimilarProduct;
  updateManySimilarProducts: (
    args: { data: SimilarProductUpdateInput; where?: SimilarProductWhereInput }
  ) => BatchPayload;
  upsertSimilarProduct: (
    args: {
      where: SimilarProductWhereUniqueInput;
      create: SimilarProductCreateInput;
      update: SimilarProductUpdateInput;
    }
  ) => SimilarProduct;
  deleteSimilarProduct: (
    where: SimilarProductWhereUniqueInput
  ) => SimilarProduct;
  deleteManySimilarProducts: (where?: SimilarProductWhereInput) => BatchPayload;
  createStore: (data: StoreCreateInput) => Store;
  updateStore: (
    args: { data: StoreUpdateInput; where: StoreWhereUniqueInput }
  ) => Store;
  updateManyStores: (
    args: { data: StoreUpdateInput; where?: StoreWhereInput }
  ) => BatchPayload;
  upsertStore: (
    args: {
      where: StoreWhereUniqueInput;
      create: StoreCreateInput;
      update: StoreUpdateInput;
    }
  ) => Store;
  deleteStore: (where: StoreWhereUniqueInput) => Store;
  deleteManyStores: (where?: StoreWhereInput) => BatchPayload;
  createTransformation: (data: TransformationCreateInput) => Transformation;
  updateTransformation: (
    args: {
      data: TransformationUpdateInput;
      where: TransformationWhereUniqueInput;
    }
  ) => Transformation;
  updateManyTransformations: (
    args: { data: TransformationUpdateInput; where?: TransformationWhereInput }
  ) => BatchPayload;
  upsertTransformation: (
    args: {
      where: TransformationWhereUniqueInput;
      create: TransformationCreateInput;
      update: TransformationUpdateInput;
    }
  ) => Transformation;
  deleteTransformation: (
    where: TransformationWhereUniqueInput
  ) => Transformation;
  deleteManyTransformations: (where?: TransformationWhereInput) => BatchPayload;
  createXhrMetaData: (data: XhrMetaDataCreateInput) => XhrMetaData;
  updateXhrMetaData: (
    args: { data: XhrMetaDataUpdateInput; where: XhrMetaDataWhereUniqueInput }
  ) => XhrMetaData;
  updateManyXhrMetaDatas: (
    args: { data: XhrMetaDataUpdateInput; where?: XhrMetaDataWhereInput }
  ) => BatchPayload;
  upsertXhrMetaData: (
    args: {
      where: XhrMetaDataWhereUniqueInput;
      create: XhrMetaDataCreateInput;
      update: XhrMetaDataUpdateInput;
    }
  ) => XhrMetaData;
  deleteXhrMetaData: (where: XhrMetaDataWhereUniqueInput) => XhrMetaData;
  deleteManyXhrMetaDatas: (where?: XhrMetaDataWhereInput) => BatchPayload;
  createfieldMetaData: (data: fieldMetaDataCreateInput) => fieldMetaData;
  updatefieldMetaData: (
    args: {
      data: fieldMetaDataUpdateInput;
      where: fieldMetaDataWhereUniqueInput;
    }
  ) => fieldMetaData;
  updateManyfieldMetaDatas: (
    args: { data: fieldMetaDataUpdateInput; where?: fieldMetaDataWhereInput }
  ) => BatchPayload;
  upsertfieldMetaData: (
    args: {
      where: fieldMetaDataWhereUniqueInput;
      create: fieldMetaDataCreateInput;
      update: fieldMetaDataUpdateInput;
    }
  ) => fieldMetaData;
  deletefieldMetaData: (where: fieldMetaDataWhereUniqueInput) => fieldMetaData;
  deleteManyfieldMetaDatas: (where?: fieldMetaDataWhereInput) => BatchPayload;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  htmlMetaData: (
    where?: HtmlMetaDataSubscriptionWhereInput
  ) => HtmlMetaDataSubscriptionPayloadSubscription;
  productFetcher: (
    where?: ProductFetcherSubscriptionWhereInput
  ) => ProductFetcherSubscriptionPayloadSubscription;
  productObservation: (
    where?: ProductObservationSubscriptionWhereInput
  ) => ProductObservationSubscriptionPayloadSubscription;
  productPage: (
    where?: ProductPageSubscriptionWhereInput
  ) => ProductPageSubscriptionPayloadSubscription;
  relatedProduct: (
    where?: RelatedProductSubscriptionWhereInput
  ) => RelatedProductSubscriptionPayloadSubscription;
  scriptMetaData: (
    where?: ScriptMetaDataSubscriptionWhereInput
  ) => ScriptMetaDataSubscriptionPayloadSubscription;
  similarProduct: (
    where?: SimilarProductSubscriptionWhereInput
  ) => SimilarProductSubscriptionPayloadSubscription;
  store: (
    where?: StoreSubscriptionWhereInput
  ) => StoreSubscriptionPayloadSubscription;
  transformation: (
    where?: TransformationSubscriptionWhereInput
  ) => TransformationSubscriptionPayloadSubscription;
  xhrMetaData: (
    where?: XhrMetaDataSubscriptionWhereInput
  ) => XhrMetaDataSubscriptionPayloadSubscription;
  fieldMetaData: (
    where?: fieldMetaDataSubscriptionWhereInput
  ) => fieldMetaDataSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ScriptMetaDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "script_ASC"
  | "script_DESC"
  | "regex_ASC"
  | "regex_DESC"
  | "propertyPath_ASC"
  | "propertyPath_DESC"
  | "transformedValue_ASC"
  | "transformedValue_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductState = "ISPO" | "CS" | "TPS" | "DIGITAL" | "CUZ";

export type HtmlMetaDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "cssSelector_ASC"
  | "cssSelector_DESC"
  | "selectedValue_ASC"
  | "selectedValue_DESC"
  | "cheerioExpression_ASC"
  | "cheerioExpression_DESC"
  | "transformedValue_ASC"
  | "transformedValue_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type fieldMetaDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductPageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "regex_ASC"
  | "regex_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TransformationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "functionName_ASC"
  | "functionName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RelatedProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "parentId_ASC"
  | "parentId_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SimilarProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "parentId_ASC"
  | "parentId_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductFetcherOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "generatedCode_ASC"
  | "generatedCode_DESC"
  | "isCompleted_ASC"
  | "isCompleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductObservationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "vimVersion_ASC"
  | "vimVersion_DESC"
  | "schemaVersion_ASC"
  | "schemaVersion_DESC"
  | "parentId_ASC"
  | "parentId_DESC"
  | "variantId_ASC"
  | "variantId_DESC"
  | "imprint_ASC"
  | "imprint_DESC"
  | "title_ASC"
  | "title_DESC"
  | "brand_ASC"
  | "brand_DESC"
  | "description_ASC"
  | "description_DESC"
  | "extDescription_ASC"
  | "extDescription_DESC"
  | "imageUrlPrimary_ASC"
  | "imageUrlPrimary_DESC"
  | "productDetails_ASC"
  | "productDetails_DESC"
  | "ratingCount_ASC"
  | "ratingCount_DESC"
  | "ratingValue_ASC"
  | "ratingValue_DESC"
  | "upc_ASC"
  | "upc_DESC"
  | "priceCurrent_ASC"
  | "priceCurrent_DESC"
  | "priceList_ASC"
  | "priceList_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "inStock_ASC"
  | "inStock_DESC"
  | "isCanoncial_ASC"
  | "isCanoncial_DESC"
  | "canonicalUrl_ASC"
  | "canonicalUrl_DESC"
  | "storeExtraInfo_ASC"
  | "storeExtraInfo_DESC"
  | "quantityInStock_ASC"
  | "quantityInStock_DESC"
  | "quantityRequired_ASC"
  | "quantityRequired_DESC"
  | "quantityAllowed_ASC"
  | "quantityAllowed_DESC"
  | "quantityIncrement_ASC"
  | "quantityIncrement_DESC"
  | "finalSale_ASC"
  | "finalSale_DESC"
  | "deals_ASC"
  | "deals_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type XhrMetaDataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "request_ASC"
  | "request_DESC"
  | "propertyPath_ASC"
  | "propertyPath_DESC"
  | "transformedValue_ASC"
  | "transformedValue_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DataSource = "XHR" | "SCRIPT" | "HTML";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type StoreOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "storeId_ASC"
  | "storeId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface ProductFetcherCreateInput {
  generatedCode?: String;
  productObservation?: ProductObservationCreateOneInput;
  isCompleted?: Boolean;
}

export type HtmlMetaDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductFetcherUpdateDataInput {
  generatedCode?: String;
  productObservation?: ProductObservationUpdateOneInput;
  isCompleted?: Boolean;
}

export interface SimilarProductUpdateWithWhereUniqueNestedInput {
  where: SimilarProductWhereUniqueInput;
  data: SimilarProductUpdateDataInput;
}

export interface ProductFetcherUpdateOneInput {
  create?: ProductFetcherCreateInput;
  update?: ProductFetcherUpdateDataInput;
  upsert?: ProductFetcherUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProductFetcherWhereUniqueInput;
}

export interface RelatedProductCreateInput {
  parentId?: String;
  url?: String;
}

export type XhrMetaDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ProductFetcherWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface StoreUpdateInput {
  storeId?: String;
  productFetcher?: ProductFetcherUpdateOneInput;
  productPages?: ProductPageUpdateManyInput;
}

export interface RelatedProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  parentId?: String;
  parentId_not?: String;
  parentId_in?: String[] | String;
  parentId_not_in?: String[] | String;
  parentId_lt?: String;
  parentId_lte?: String;
  parentId_gt?: String;
  parentId_gte?: String;
  parentId_contains?: String;
  parentId_not_contains?: String;
  parentId_starts_with?: String;
  parentId_not_starts_with?: String;
  parentId_ends_with?: String;
  parentId_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: RelatedProductWhereInput[] | RelatedProductWhereInput;
  OR?: RelatedProductWhereInput[] | RelatedProductWhereInput;
  NOT?: RelatedProductWhereInput[] | RelatedProductWhereInput;
}

export interface XhrMetaDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  propertyPath?: String;
  propertyPath_not?: String;
  propertyPath_in?: String[] | String;
  propertyPath_not_in?: String[] | String;
  propertyPath_lt?: String;
  propertyPath_lte?: String;
  propertyPath_gt?: String;
  propertyPath_gte?: String;
  propertyPath_contains?: String;
  propertyPath_not_contains?: String;
  propertyPath_starts_with?: String;
  propertyPath_not_starts_with?: String;
  propertyPath_ends_with?: String;
  propertyPath_not_ends_with?: String;
  transformations_every?: TransformationWhereInput;
  transformations_some?: TransformationWhereInput;
  transformations_none?: TransformationWhereInput;
  transformedValue?: String;
  transformedValue_not?: String;
  transformedValue_in?: String[] | String;
  transformedValue_not_in?: String[] | String;
  transformedValue_lt?: String;
  transformedValue_lte?: String;
  transformedValue_gt?: String;
  transformedValue_gte?: String;
  transformedValue_contains?: String;
  transformedValue_not_contains?: String;
  transformedValue_starts_with?: String;
  transformedValue_not_starts_with?: String;
  transformedValue_ends_with?: String;
  transformedValue_not_ends_with?: String;
  AND?: XhrMetaDataWhereInput[] | XhrMetaDataWhereInput;
  OR?: XhrMetaDataWhereInput[] | XhrMetaDataWhereInput;
  NOT?: XhrMetaDataWhereInput[] | XhrMetaDataWhereInput;
}

export interface StoreSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StoreWhereInput;
  AND?: StoreSubscriptionWhereInput[] | StoreSubscriptionWhereInput;
  OR?: StoreSubscriptionWhereInput[] | StoreSubscriptionWhereInput;
  NOT?: StoreSubscriptionWhereInput[] | StoreSubscriptionWhereInput;
}

export interface ProductPageCreateManyInput {
  create?: ProductPageCreateInput[] | ProductPageCreateInput;
  connect?: ProductPageWhereUniqueInput[] | ProductPageWhereUniqueInput;
}

export interface SimilarProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SimilarProductWhereInput;
  AND?:
    | SimilarProductSubscriptionWhereInput[]
    | SimilarProductSubscriptionWhereInput;
  OR?:
    | SimilarProductSubscriptionWhereInput[]
    | SimilarProductSubscriptionWhereInput;
  NOT?:
    | SimilarProductSubscriptionWhereInput[]
    | SimilarProductSubscriptionWhereInput;
}

export interface ProductFetcherCreateOneInput {
  create?: ProductFetcherCreateInput;
  connect?: ProductFetcherWhereUniqueInput;
}

export interface ProductFetcherWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  generatedCode?: String;
  generatedCode_not?: String;
  generatedCode_in?: String[] | String;
  generatedCode_not_in?: String[] | String;
  generatedCode_lt?: String;
  generatedCode_lte?: String;
  generatedCode_gt?: String;
  generatedCode_gte?: String;
  generatedCode_contains?: String;
  generatedCode_not_contains?: String;
  generatedCode_starts_with?: String;
  generatedCode_not_starts_with?: String;
  generatedCode_ends_with?: String;
  generatedCode_not_ends_with?: String;
  productObservation?: ProductObservationWhereInput;
  isCompleted?: Boolean;
  isCompleted_not?: Boolean;
  AND?: ProductFetcherWhereInput[] | ProductFetcherWhereInput;
  OR?: ProductFetcherWhereInput[] | ProductFetcherWhereInput;
  NOT?: ProductFetcherWhereInput[] | ProductFetcherWhereInput;
}

export interface StoreCreateInput {
  storeId: String;
  productFetcher?: ProductFetcherCreateOneInput;
  productPages?: ProductPageCreateManyInput;
}

export interface RelatedProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RelatedProductWhereInput;
  AND?:
    | RelatedProductSubscriptionWhereInput[]
    | RelatedProductSubscriptionWhereInput;
  OR?:
    | RelatedProductSubscriptionWhereInput[]
    | RelatedProductSubscriptionWhereInput;
  NOT?:
    | RelatedProductSubscriptionWhereInput[]
    | RelatedProductSubscriptionWhereInput;
}

export interface SimilarProductUpdateInput {
  parentId?: String;
  url?: String;
}

export interface ProductObservationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductObservationWhereInput;
  AND?:
    | ProductObservationSubscriptionWhereInput[]
    | ProductObservationSubscriptionWhereInput;
  OR?:
    | ProductObservationSubscriptionWhereInput[]
    | ProductObservationSubscriptionWhereInput;
  NOT?:
    | ProductObservationSubscriptionWhereInput[]
    | ProductObservationSubscriptionWhereInput;
}

export type fieldMetaDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export type ProductObservationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScriptMetaDataUpdateInput {
  script?: Json;
  regex?: String;
  propertyPath?: String;
  transformations?: TransformationUpdateManyInput;
  transformedValue?: String;
}

export interface HtmlMetaDataUpsertNestedInput {
  update: HtmlMetaDataUpdateDataInput;
  create: HtmlMetaDataCreateInput;
}

export interface TransformationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  functionName?: String;
  functionName_not?: String;
  functionName_in?: String[] | String;
  functionName_not_in?: String[] | String;
  functionName_lt?: String;
  functionName_lte?: String;
  functionName_gt?: String;
  functionName_gte?: String;
  functionName_contains?: String;
  functionName_not_contains?: String;
  functionName_starts_with?: String;
  functionName_not_starts_with?: String;
  functionName_ends_with?: String;
  functionName_not_ends_with?: String;
  AND?: TransformationWhereInput[] | TransformationWhereInput;
  OR?: TransformationWhereInput[] | TransformationWhereInput;
  NOT?: TransformationWhereInput[] | TransformationWhereInput;
}

export interface HtmlMetaDataUpdateOneInput {
  create?: HtmlMetaDataCreateInput;
  update?: HtmlMetaDataUpdateDataInput;
  upsert?: HtmlMetaDataUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: HtmlMetaDataWhereUniqueInput;
}

export interface fieldMetaDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  xhrMetaData?: XhrMetaDataWhereInput;
  scriptMetaData?: ScriptMetaDataWhereInput;
  htmlMetaData?: HtmlMetaDataWhereInput;
  AND?: fieldMetaDataWhereInput[] | fieldMetaDataWhereInput;
  OR?: fieldMetaDataWhereInput[] | fieldMetaDataWhereInput;
  NOT?: fieldMetaDataWhereInput[] | fieldMetaDataWhereInput;
}

export interface ScriptMetaDataUpsertNestedInput {
  update: ScriptMetaDataUpdateDataInput;
  create: ScriptMetaDataCreateInput;
}

export interface ScriptMetaDataCreateInput {
  script?: Json;
  regex?: String;
  propertyPath?: String;
  transformations?: TransformationCreateManyInput;
  transformedValue?: String;
}

export interface ScriptMetaDataUpdateDataInput {
  script?: Json;
  regex?: String;
  propertyPath?: String;
  transformations?: TransformationUpdateManyInput;
  transformedValue?: String;
}

export interface RelatedProductUpdateInput {
  parentId?: String;
  url?: String;
}

export interface XhrMetaDataUpsertNestedInput {
  update: XhrMetaDataUpdateDataInput;
  create: XhrMetaDataCreateInput;
}

export interface ProductPageUpdateInput {
  url?: String;
  regex?: String;
}

export type RelatedProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  url?: String;
}>;

export interface ProductPageCreateInput {
  url: String;
  regex?: String;
}

export interface fieldMetaDataUpdatefoundInInput {
  set?: DataSource[] | DataSource;
}

export type ScriptMetaDataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScriptMetaDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  regex?: String;
  regex_not?: String;
  regex_in?: String[] | String;
  regex_not_in?: String[] | String;
  regex_lt?: String;
  regex_lte?: String;
  regex_gt?: String;
  regex_gte?: String;
  regex_contains?: String;
  regex_not_contains?: String;
  regex_starts_with?: String;
  regex_not_starts_with?: String;
  regex_ends_with?: String;
  regex_not_ends_with?: String;
  propertyPath?: String;
  propertyPath_not?: String;
  propertyPath_in?: String[] | String;
  propertyPath_not_in?: String[] | String;
  propertyPath_lt?: String;
  propertyPath_lte?: String;
  propertyPath_gt?: String;
  propertyPath_gte?: String;
  propertyPath_contains?: String;
  propertyPath_not_contains?: String;
  propertyPath_starts_with?: String;
  propertyPath_not_starts_with?: String;
  propertyPath_ends_with?: String;
  propertyPath_not_ends_with?: String;
  transformations_every?: TransformationWhereInput;
  transformations_some?: TransformationWhereInput;
  transformations_none?: TransformationWhereInput;
  transformedValue?: String;
  transformedValue_not?: String;
  transformedValue_in?: String[] | String;
  transformedValue_not_in?: String[] | String;
  transformedValue_lt?: String;
  transformedValue_lte?: String;
  transformedValue_gt?: String;
  transformedValue_gte?: String;
  transformedValue_contains?: String;
  transformedValue_not_contains?: String;
  transformedValue_starts_with?: String;
  transformedValue_not_starts_with?: String;
  transformedValue_ends_with?: String;
  transformedValue_not_ends_with?: String;
  AND?: ScriptMetaDataWhereInput[] | ScriptMetaDataWhereInput;
  OR?: ScriptMetaDataWhereInput[] | ScriptMetaDataWhereInput;
  NOT?: ScriptMetaDataWhereInput[] | ScriptMetaDataWhereInput;
}

export interface HtmlMetaDataCreateInput {
  cssSelector?: String;
  selectedValue?: String;
  cheerioExpression?: String;
  transformations?: TransformationCreateManyInput;
  transformedValue?: String;
}

export interface ScriptMetaDataCreateOneInput {
  create?: ScriptMetaDataCreateInput;
  connect?: ScriptMetaDataWhereUniqueInput;
}

export interface TransformationCreateManyInput {
  create?: TransformationCreateInput[] | TransformationCreateInput;
  connect?: TransformationWhereUniqueInput[] | TransformationWhereUniqueInput;
}

export interface fieldMetaDataCreatefoundInInput {
  set?: DataSource[] | DataSource;
}

export interface TransformationCreateInput {
  functionName: String;
}

export interface fieldMetaDataCreateInput {
  name: String;
  foundIn?: fieldMetaDataCreatefoundInInput;
  xhrMetaData?: XhrMetaDataCreateOneInput;
  scriptMetaData?: ScriptMetaDataCreateOneInput;
  htmlMetaData?: HtmlMetaDataCreateOneInput;
}

export interface HtmlMetaDataUpdateInput {
  cssSelector?: String;
  selectedValue?: String;
  cheerioExpression?: String;
  transformations?: TransformationUpdateManyInput;
  transformedValue?: String;
}

export interface XhrMetaDataCreateInput {
  request?: Json;
  propertyPath?: String;
  transformations?: TransformationCreateManyInput;
  transformedValue?: String;
}

export interface TransformationUpdateManyInput {
  create?: TransformationCreateInput[] | TransformationCreateInput;
  update?:
    | TransformationUpdateWithWhereUniqueNestedInput[]
    | TransformationUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TransformationUpsertWithWhereUniqueNestedInput[]
    | TransformationUpsertWithWhereUniqueNestedInput;
  delete?: TransformationWhereUniqueInput[] | TransformationWhereUniqueInput;
  connect?: TransformationWhereUniqueInput[] | TransformationWhereUniqueInput;
  disconnect?:
    | TransformationWhereUniqueInput[]
    | TransformationWhereUniqueInput;
}

export interface TransformationUpdateInput {
  functionName?: String;
}

export interface TransformationUpdateWithWhereUniqueNestedInput {
  where: TransformationWhereUniqueInput;
  data: TransformationUpdateDataInput;
}

export interface ProductPageUpsertWithWhereUniqueNestedInput {
  where: ProductPageWhereUniqueInput;
  update: ProductPageUpdateDataInput;
  create: ProductPageCreateInput;
}

export interface TransformationUpdateDataInput {
  functionName?: String;
}

export interface ProductPageUpdateWithWhereUniqueNestedInput {
  where: ProductPageWhereUniqueInput;
  data: ProductPageUpdateDataInput;
}

export interface TransformationUpsertWithWhereUniqueNestedInput {
  where: TransformationWhereUniqueInput;
  update: TransformationUpdateDataInput;
  create: TransformationCreateInput;
}

export type TransformationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  functionName?: String;
}>;

export interface ProductObservationUpdateInput {
  vimVersion?: String;
  schemaVersion?: String;
  parentId?: String;
  variantId?: String;
  imprint?: Boolean;
  title?: String;
  brand?: String;
  description?: String;
  extDescription?: String;
  imageUrlPrimary?: String;
  imageUrlSecondaries?: ProductObservationUpdateimageUrlSecondariesInput;
  productDetails?: Json;
  productStates?: ProductObservationUpdateproductStatesInput;
  ratingCount?: Int;
  ratingValue?: Int;
  keywords?: ProductObservationUpdatekeywordsInput;
  categories?: ProductObservationUpdatecategoriesInput;
  upc?: String;
  priceCurrent?: Float;
  priceList?: Float;
  currency?: String;
  inStock?: Boolean;
  isCanoncial?: Boolean;
  canonicalUrl?: String;
  storeExtraInfo?: Json;
  relatedProducts?: RelatedProductUpdateManyInput;
  similarProducts?: SimilarProductUpdateManyInput;
  quantityInStock?: Int;
  quantityRequired?: Int;
  quantityAllowed?: Int;
  quantityIncrement?: Int;
  finalSale?: Boolean;
  deals?: String;
}

export interface fieldMetaDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: fieldMetaDataWhereInput;
  AND?:
    | fieldMetaDataSubscriptionWhereInput[]
    | fieldMetaDataSubscriptionWhereInput;
  OR?:
    | fieldMetaDataSubscriptionWhereInput[]
    | fieldMetaDataSubscriptionWhereInput;
  NOT?:
    | fieldMetaDataSubscriptionWhereInput[]
    | fieldMetaDataSubscriptionWhereInput;
}

export interface ProductObservationUpsertNestedInput {
  update: ProductObservationUpdateDataInput;
  create: ProductObservationCreateInput;
}

export interface TransformationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TransformationWhereInput;
  AND?:
    | TransformationSubscriptionWhereInput[]
    | TransformationSubscriptionWhereInput;
  OR?:
    | TransformationSubscriptionWhereInput[]
    | TransformationSubscriptionWhereInput;
  NOT?:
    | TransformationSubscriptionWhereInput[]
    | TransformationSubscriptionWhereInput;
}

export interface SimilarProductUpsertWithWhereUniqueNestedInput {
  where: SimilarProductWhereUniqueInput;
  update: SimilarProductUpdateDataInput;
  create: SimilarProductCreateInput;
}

export interface ScriptMetaDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScriptMetaDataWhereInput;
  AND?:
    | ScriptMetaDataSubscriptionWhereInput[]
    | ScriptMetaDataSubscriptionWhereInput;
  OR?:
    | ScriptMetaDataSubscriptionWhereInput[]
    | ScriptMetaDataSubscriptionWhereInput;
  NOT?:
    | ScriptMetaDataSubscriptionWhereInput[]
    | ScriptMetaDataSubscriptionWhereInput;
}

export interface ProductObservationCreateOneInput {
  create?: ProductObservationCreateInput;
  connect?: ProductObservationWhereUniqueInput;
}

export interface ProductPageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductPageWhereInput;
  AND?: ProductPageSubscriptionWhereInput[] | ProductPageSubscriptionWhereInput;
  OR?: ProductPageSubscriptionWhereInput[] | ProductPageSubscriptionWhereInput;
  NOT?: ProductPageSubscriptionWhereInput[] | ProductPageSubscriptionWhereInput;
}

export interface ProductObservationCreateInput {
  vimVersion?: String;
  schemaVersion?: String;
  parentId?: String;
  variantId?: String;
  imprint?: Boolean;
  title?: String;
  brand?: String;
  description?: String;
  extDescription?: String;
  imageUrlPrimary?: String;
  imageUrlSecondaries?: ProductObservationCreateimageUrlSecondariesInput;
  productDetails?: Json;
  productStates?: ProductObservationCreateproductStatesInput;
  ratingCount?: Int;
  ratingValue?: Int;
  keywords?: ProductObservationCreatekeywordsInput;
  categories?: ProductObservationCreatecategoriesInput;
  upc?: String;
  priceCurrent?: Float;
  priceList?: Float;
  currency?: String;
  inStock?: Boolean;
  isCanoncial?: Boolean;
  canonicalUrl?: String;
  storeExtraInfo?: Json;
  relatedProducts?: RelatedProductCreateManyInput;
  similarProducts?: SimilarProductCreateManyInput;
  quantityInStock?: Int;
  quantityRequired?: Int;
  quantityAllowed?: Int;
  quantityIncrement?: Int;
  finalSale?: Boolean;
  deals?: String;
}

export interface HtmlMetaDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HtmlMetaDataWhereInput;
  AND?:
    | HtmlMetaDataSubscriptionWhereInput[]
    | HtmlMetaDataSubscriptionWhereInput;
  OR?:
    | HtmlMetaDataSubscriptionWhereInput[]
    | HtmlMetaDataSubscriptionWhereInput;
  NOT?:
    | HtmlMetaDataSubscriptionWhereInput[]
    | HtmlMetaDataSubscriptionWhereInput;
}

export interface ProductObservationCreateimageUrlSecondariesInput {
  set?: String[] | String;
}

export type ProductPageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  url?: String;
}>;

export interface ProductObservationCreateproductStatesInput {
  set?: ProductState[] | ProductState;
}

export interface ScriptMetaDataUpdateOneInput {
  create?: ScriptMetaDataCreateInput;
  update?: ScriptMetaDataUpdateDataInput;
  upsert?: ScriptMetaDataUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ScriptMetaDataWhereUniqueInput;
}

export interface ProductObservationCreatekeywordsInput {
  set?: String[] | String;
}

export interface XhrMetaDataUpdateOneInput {
  create?: XhrMetaDataCreateInput;
  update?: XhrMetaDataUpdateDataInput;
  upsert?: XhrMetaDataUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: XhrMetaDataWhereUniqueInput;
}

export interface ProductObservationCreatecategoriesInput {
  set?: String[] | String;
}

export interface HtmlMetaDataCreateOneInput {
  create?: HtmlMetaDataCreateInput;
  connect?: HtmlMetaDataWhereUniqueInput;
}

export interface RelatedProductCreateManyInput {
  create?: RelatedProductCreateInput[] | RelatedProductCreateInput;
  connect?: RelatedProductWhereUniqueInput[] | RelatedProductWhereUniqueInput;
}

export interface XhrMetaDataCreateOneInput {
  create?: XhrMetaDataCreateInput;
  connect?: XhrMetaDataWhereUniqueInput;
}

export interface SimilarProductUpdateDataInput {
  parentId?: String;
  url?: String;
}

export interface XhrMetaDataUpdateInput {
  request?: Json;
  propertyPath?: String;
  transformations?: TransformationUpdateManyInput;
  transformedValue?: String;
}

export interface SimilarProductCreateManyInput {
  create?: SimilarProductCreateInput[] | SimilarProductCreateInput;
  connect?: SimilarProductWhereUniqueInput[] | SimilarProductWhereUniqueInput;
}

export interface StoreWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  storeId?: String;
  storeId_not?: String;
  storeId_in?: String[] | String;
  storeId_not_in?: String[] | String;
  storeId_lt?: String;
  storeId_lte?: String;
  storeId_gt?: String;
  storeId_gte?: String;
  storeId_contains?: String;
  storeId_not_contains?: String;
  storeId_starts_with?: String;
  storeId_not_starts_with?: String;
  storeId_ends_with?: String;
  storeId_not_ends_with?: String;
  productFetcher?: ProductFetcherWhereInput;
  productPages_every?: ProductPageWhereInput;
  productPages_some?: ProductPageWhereInput;
  productPages_none?: ProductPageWhereInput;
  AND?: StoreWhereInput[] | StoreWhereInput;
  OR?: StoreWhereInput[] | StoreWhereInput;
  NOT?: StoreWhereInput[] | StoreWhereInput;
}

export interface SimilarProductCreateInput {
  parentId?: String;
  url?: String;
}

export interface ProductPageUpdateManyInput {
  create?: ProductPageCreateInput[] | ProductPageCreateInput;
  update?:
    | ProductPageUpdateWithWhereUniqueNestedInput[]
    | ProductPageUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ProductPageUpsertWithWhereUniqueNestedInput[]
    | ProductPageUpsertWithWhereUniqueNestedInput;
  delete?: ProductPageWhereUniqueInput[] | ProductPageWhereUniqueInput;
  connect?: ProductPageWhereUniqueInput[] | ProductPageWhereUniqueInput;
  disconnect?: ProductPageWhereUniqueInput[] | ProductPageWhereUniqueInput;
}

export interface ProductFetcherUpdateInput {
  generatedCode?: String;
  productObservation?: ProductObservationUpdateOneInput;
  isCompleted?: Boolean;
}

export interface XhrMetaDataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: XhrMetaDataWhereInput;
  AND?: XhrMetaDataSubscriptionWhereInput[] | XhrMetaDataSubscriptionWhereInput;
  OR?: XhrMetaDataSubscriptionWhereInput[] | XhrMetaDataSubscriptionWhereInput;
  NOT?: XhrMetaDataSubscriptionWhereInput[] | XhrMetaDataSubscriptionWhereInput;
}

export interface ProductObservationUpdateOneInput {
  create?: ProductObservationCreateInput;
  update?: ProductObservationUpdateDataInput;
  upsert?: ProductObservationUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProductObservationWhereUniqueInput;
}

export interface ProductObservationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  vimVersion?: String;
  vimVersion_not?: String;
  vimVersion_in?: String[] | String;
  vimVersion_not_in?: String[] | String;
  vimVersion_lt?: String;
  vimVersion_lte?: String;
  vimVersion_gt?: String;
  vimVersion_gte?: String;
  vimVersion_contains?: String;
  vimVersion_not_contains?: String;
  vimVersion_starts_with?: String;
  vimVersion_not_starts_with?: String;
  vimVersion_ends_with?: String;
  vimVersion_not_ends_with?: String;
  schemaVersion?: String;
  schemaVersion_not?: String;
  schemaVersion_in?: String[] | String;
  schemaVersion_not_in?: String[] | String;
  schemaVersion_lt?: String;
  schemaVersion_lte?: String;
  schemaVersion_gt?: String;
  schemaVersion_gte?: String;
  schemaVersion_contains?: String;
  schemaVersion_not_contains?: String;
  schemaVersion_starts_with?: String;
  schemaVersion_not_starts_with?: String;
  schemaVersion_ends_with?: String;
  schemaVersion_not_ends_with?: String;
  parentId?: String;
  parentId_not?: String;
  parentId_in?: String[] | String;
  parentId_not_in?: String[] | String;
  parentId_lt?: String;
  parentId_lte?: String;
  parentId_gt?: String;
  parentId_gte?: String;
  parentId_contains?: String;
  parentId_not_contains?: String;
  parentId_starts_with?: String;
  parentId_not_starts_with?: String;
  parentId_ends_with?: String;
  parentId_not_ends_with?: String;
  variantId?: String;
  variantId_not?: String;
  variantId_in?: String[] | String;
  variantId_not_in?: String[] | String;
  variantId_lt?: String;
  variantId_lte?: String;
  variantId_gt?: String;
  variantId_gte?: String;
  variantId_contains?: String;
  variantId_not_contains?: String;
  variantId_starts_with?: String;
  variantId_not_starts_with?: String;
  variantId_ends_with?: String;
  variantId_not_ends_with?: String;
  imprint?: Boolean;
  imprint_not?: Boolean;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  brand?: String;
  brand_not?: String;
  brand_in?: String[] | String;
  brand_not_in?: String[] | String;
  brand_lt?: String;
  brand_lte?: String;
  brand_gt?: String;
  brand_gte?: String;
  brand_contains?: String;
  brand_not_contains?: String;
  brand_starts_with?: String;
  brand_not_starts_with?: String;
  brand_ends_with?: String;
  brand_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  extDescription?: String;
  extDescription_not?: String;
  extDescription_in?: String[] | String;
  extDescription_not_in?: String[] | String;
  extDescription_lt?: String;
  extDescription_lte?: String;
  extDescription_gt?: String;
  extDescription_gte?: String;
  extDescription_contains?: String;
  extDescription_not_contains?: String;
  extDescription_starts_with?: String;
  extDescription_not_starts_with?: String;
  extDescription_ends_with?: String;
  extDescription_not_ends_with?: String;
  imageUrlPrimary?: String;
  imageUrlPrimary_not?: String;
  imageUrlPrimary_in?: String[] | String;
  imageUrlPrimary_not_in?: String[] | String;
  imageUrlPrimary_lt?: String;
  imageUrlPrimary_lte?: String;
  imageUrlPrimary_gt?: String;
  imageUrlPrimary_gte?: String;
  imageUrlPrimary_contains?: String;
  imageUrlPrimary_not_contains?: String;
  imageUrlPrimary_starts_with?: String;
  imageUrlPrimary_not_starts_with?: String;
  imageUrlPrimary_ends_with?: String;
  imageUrlPrimary_not_ends_with?: String;
  ratingCount?: Int;
  ratingCount_not?: Int;
  ratingCount_in?: Int[] | Int;
  ratingCount_not_in?: Int[] | Int;
  ratingCount_lt?: Int;
  ratingCount_lte?: Int;
  ratingCount_gt?: Int;
  ratingCount_gte?: Int;
  ratingValue?: Int;
  ratingValue_not?: Int;
  ratingValue_in?: Int[] | Int;
  ratingValue_not_in?: Int[] | Int;
  ratingValue_lt?: Int;
  ratingValue_lte?: Int;
  ratingValue_gt?: Int;
  ratingValue_gte?: Int;
  upc?: String;
  upc_not?: String;
  upc_in?: String[] | String;
  upc_not_in?: String[] | String;
  upc_lt?: String;
  upc_lte?: String;
  upc_gt?: String;
  upc_gte?: String;
  upc_contains?: String;
  upc_not_contains?: String;
  upc_starts_with?: String;
  upc_not_starts_with?: String;
  upc_ends_with?: String;
  upc_not_ends_with?: String;
  priceCurrent?: Float;
  priceCurrent_not?: Float;
  priceCurrent_in?: Float[] | Float;
  priceCurrent_not_in?: Float[] | Float;
  priceCurrent_lt?: Float;
  priceCurrent_lte?: Float;
  priceCurrent_gt?: Float;
  priceCurrent_gte?: Float;
  priceList?: Float;
  priceList_not?: Float;
  priceList_in?: Float[] | Float;
  priceList_not_in?: Float[] | Float;
  priceList_lt?: Float;
  priceList_lte?: Float;
  priceList_gt?: Float;
  priceList_gte?: Float;
  currency?: String;
  currency_not?: String;
  currency_in?: String[] | String;
  currency_not_in?: String[] | String;
  currency_lt?: String;
  currency_lte?: String;
  currency_gt?: String;
  currency_gte?: String;
  currency_contains?: String;
  currency_not_contains?: String;
  currency_starts_with?: String;
  currency_not_starts_with?: String;
  currency_ends_with?: String;
  currency_not_ends_with?: String;
  inStock?: Boolean;
  inStock_not?: Boolean;
  isCanoncial?: Boolean;
  isCanoncial_not?: Boolean;
  canonicalUrl?: String;
  canonicalUrl_not?: String;
  canonicalUrl_in?: String[] | String;
  canonicalUrl_not_in?: String[] | String;
  canonicalUrl_lt?: String;
  canonicalUrl_lte?: String;
  canonicalUrl_gt?: String;
  canonicalUrl_gte?: String;
  canonicalUrl_contains?: String;
  canonicalUrl_not_contains?: String;
  canonicalUrl_starts_with?: String;
  canonicalUrl_not_starts_with?: String;
  canonicalUrl_ends_with?: String;
  canonicalUrl_not_ends_with?: String;
  relatedProducts_every?: RelatedProductWhereInput;
  relatedProducts_some?: RelatedProductWhereInput;
  relatedProducts_none?: RelatedProductWhereInput;
  similarProducts_every?: SimilarProductWhereInput;
  similarProducts_some?: SimilarProductWhereInput;
  similarProducts_none?: SimilarProductWhereInput;
  quantityInStock?: Int;
  quantityInStock_not?: Int;
  quantityInStock_in?: Int[] | Int;
  quantityInStock_not_in?: Int[] | Int;
  quantityInStock_lt?: Int;
  quantityInStock_lte?: Int;
  quantityInStock_gt?: Int;
  quantityInStock_gte?: Int;
  quantityRequired?: Int;
  quantityRequired_not?: Int;
  quantityRequired_in?: Int[] | Int;
  quantityRequired_not_in?: Int[] | Int;
  quantityRequired_lt?: Int;
  quantityRequired_lte?: Int;
  quantityRequired_gt?: Int;
  quantityRequired_gte?: Int;
  quantityAllowed?: Int;
  quantityAllowed_not?: Int;
  quantityAllowed_in?: Int[] | Int;
  quantityAllowed_not_in?: Int[] | Int;
  quantityAllowed_lt?: Int;
  quantityAllowed_lte?: Int;
  quantityAllowed_gt?: Int;
  quantityAllowed_gte?: Int;
  quantityIncrement?: Int;
  quantityIncrement_not?: Int;
  quantityIncrement_in?: Int[] | Int;
  quantityIncrement_not_in?: Int[] | Int;
  quantityIncrement_lt?: Int;
  quantityIncrement_lte?: Int;
  quantityIncrement_gt?: Int;
  quantityIncrement_gte?: Int;
  finalSale?: Boolean;
  finalSale_not?: Boolean;
  deals?: String;
  deals_not?: String;
  deals_in?: String[] | String;
  deals_not_in?: String[] | String;
  deals_lt?: String;
  deals_lte?: String;
  deals_gt?: String;
  deals_gte?: String;
  deals_contains?: String;
  deals_not_contains?: String;
  deals_starts_with?: String;
  deals_not_starts_with?: String;
  deals_ends_with?: String;
  deals_not_ends_with?: String;
  AND?: ProductObservationWhereInput[] | ProductObservationWhereInput;
  OR?: ProductObservationWhereInput[] | ProductObservationWhereInput;
  NOT?: ProductObservationWhereInput[] | ProductObservationWhereInput;
}

export interface ProductObservationUpdateDataInput {
  vimVersion?: String;
  schemaVersion?: String;
  parentId?: String;
  variantId?: String;
  imprint?: Boolean;
  title?: String;
  brand?: String;
  description?: String;
  extDescription?: String;
  imageUrlPrimary?: String;
  imageUrlSecondaries?: ProductObservationUpdateimageUrlSecondariesInput;
  productDetails?: Json;
  productStates?: ProductObservationUpdateproductStatesInput;
  ratingCount?: Int;
  ratingValue?: Int;
  keywords?: ProductObservationUpdatekeywordsInput;
  categories?: ProductObservationUpdatecategoriesInput;
  upc?: String;
  priceCurrent?: Float;
  priceList?: Float;
  currency?: String;
  inStock?: Boolean;
  isCanoncial?: Boolean;
  canonicalUrl?: String;
  storeExtraInfo?: Json;
  relatedProducts?: RelatedProductUpdateManyInput;
  similarProducts?: SimilarProductUpdateManyInput;
  quantityInStock?: Int;
  quantityRequired?: Int;
  quantityAllowed?: Int;
  quantityIncrement?: Int;
  finalSale?: Boolean;
  deals?: String;
}

export interface HtmlMetaDataUpdateDataInput {
  cssSelector?: String;
  selectedValue?: String;
  cheerioExpression?: String;
  transformations?: TransformationUpdateManyInput;
  transformedValue?: String;
}

export interface ProductObservationUpdateimageUrlSecondariesInput {
  set?: String[] | String;
}

export interface XhrMetaDataUpdateDataInput {
  request?: Json;
  propertyPath?: String;
  transformations?: TransformationUpdateManyInput;
  transformedValue?: String;
}

export interface ProductObservationUpdateproductStatesInput {
  set?: ProductState[] | ProductState;
}

export interface HtmlMetaDataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  cssSelector?: String;
  cssSelector_not?: String;
  cssSelector_in?: String[] | String;
  cssSelector_not_in?: String[] | String;
  cssSelector_lt?: String;
  cssSelector_lte?: String;
  cssSelector_gt?: String;
  cssSelector_gte?: String;
  cssSelector_contains?: String;
  cssSelector_not_contains?: String;
  cssSelector_starts_with?: String;
  cssSelector_not_starts_with?: String;
  cssSelector_ends_with?: String;
  cssSelector_not_ends_with?: String;
  selectedValue?: String;
  selectedValue_not?: String;
  selectedValue_in?: String[] | String;
  selectedValue_not_in?: String[] | String;
  selectedValue_lt?: String;
  selectedValue_lte?: String;
  selectedValue_gt?: String;
  selectedValue_gte?: String;
  selectedValue_contains?: String;
  selectedValue_not_contains?: String;
  selectedValue_starts_with?: String;
  selectedValue_not_starts_with?: String;
  selectedValue_ends_with?: String;
  selectedValue_not_ends_with?: String;
  cheerioExpression?: String;
  cheerioExpression_not?: String;
  cheerioExpression_in?: String[] | String;
  cheerioExpression_not_in?: String[] | String;
  cheerioExpression_lt?: String;
  cheerioExpression_lte?: String;
  cheerioExpression_gt?: String;
  cheerioExpression_gte?: String;
  cheerioExpression_contains?: String;
  cheerioExpression_not_contains?: String;
  cheerioExpression_starts_with?: String;
  cheerioExpression_not_starts_with?: String;
  cheerioExpression_ends_with?: String;
  cheerioExpression_not_ends_with?: String;
  transformations_every?: TransformationWhereInput;
  transformations_some?: TransformationWhereInput;
  transformations_none?: TransformationWhereInput;
  transformedValue?: String;
  transformedValue_not?: String;
  transformedValue_in?: String[] | String;
  transformedValue_not_in?: String[] | String;
  transformedValue_lt?: String;
  transformedValue_lte?: String;
  transformedValue_gt?: String;
  transformedValue_gte?: String;
  transformedValue_contains?: String;
  transformedValue_not_contains?: String;
  transformedValue_starts_with?: String;
  transformedValue_not_starts_with?: String;
  transformedValue_ends_with?: String;
  transformedValue_not_ends_with?: String;
  AND?: HtmlMetaDataWhereInput[] | HtmlMetaDataWhereInput;
  OR?: HtmlMetaDataWhereInput[] | HtmlMetaDataWhereInput;
  NOT?: HtmlMetaDataWhereInput[] | HtmlMetaDataWhereInput;
}

export interface ProductObservationUpdatekeywordsInput {
  set?: String[] | String;
}

export type StoreWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  storeId?: String;
}>;

export interface ProductObservationUpdatecategoriesInput {
  set?: String[] | String;
}

export interface ProductFetcherUpsertNestedInput {
  update: ProductFetcherUpdateDataInput;
  create: ProductFetcherCreateInput;
}

export interface RelatedProductUpdateManyInput {
  create?: RelatedProductCreateInput[] | RelatedProductCreateInput;
  update?:
    | RelatedProductUpdateWithWhereUniqueNestedInput[]
    | RelatedProductUpdateWithWhereUniqueNestedInput;
  upsert?:
    | RelatedProductUpsertWithWhereUniqueNestedInput[]
    | RelatedProductUpsertWithWhereUniqueNestedInput;
  delete?: RelatedProductWhereUniqueInput[] | RelatedProductWhereUniqueInput;
  connect?: RelatedProductWhereUniqueInput[] | RelatedProductWhereUniqueInput;
  disconnect?:
    | RelatedProductWhereUniqueInput[]
    | RelatedProductWhereUniqueInput;
}

export interface ProductFetcherSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductFetcherWhereInput;
  AND?:
    | ProductFetcherSubscriptionWhereInput[]
    | ProductFetcherSubscriptionWhereInput;
  OR?:
    | ProductFetcherSubscriptionWhereInput[]
    | ProductFetcherSubscriptionWhereInput;
  NOT?:
    | ProductFetcherSubscriptionWhereInput[]
    | ProductFetcherSubscriptionWhereInput;
}

export interface SimilarProductUpdateManyInput {
  create?: SimilarProductCreateInput[] | SimilarProductCreateInput;
  update?:
    | SimilarProductUpdateWithWhereUniqueNestedInput[]
    | SimilarProductUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SimilarProductUpsertWithWhereUniqueNestedInput[]
    | SimilarProductUpsertWithWhereUniqueNestedInput;
  delete?: SimilarProductWhereUniqueInput[] | SimilarProductWhereUniqueInput;
  connect?: SimilarProductWhereUniqueInput[] | SimilarProductWhereUniqueInput;
  disconnect?:
    | SimilarProductWhereUniqueInput[]
    | SimilarProductWhereUniqueInput;
}

export interface RelatedProductUpsertWithWhereUniqueNestedInput {
  where: RelatedProductWhereUniqueInput;
  update: RelatedProductUpdateDataInput;
  create: RelatedProductCreateInput;
}

export interface RelatedProductUpdateDataInput {
  parentId?: String;
  url?: String;
}

export interface RelatedProductUpdateWithWhereUniqueNestedInput {
  where: RelatedProductWhereUniqueInput;
  data: RelatedProductUpdateDataInput;
}

export interface ProductPageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  regex?: String;
  regex_not?: String;
  regex_in?: String[] | String;
  regex_not_in?: String[] | String;
  regex_lt?: String;
  regex_lte?: String;
  regex_gt?: String;
  regex_gte?: String;
  regex_contains?: String;
  regex_not_contains?: String;
  regex_starts_with?: String;
  regex_not_starts_with?: String;
  regex_ends_with?: String;
  regex_not_ends_with?: String;
  AND?: ProductPageWhereInput[] | ProductPageWhereInput;
  OR?: ProductPageWhereInput[] | ProductPageWhereInput;
  NOT?: ProductPageWhereInput[] | ProductPageWhereInput;
}

export interface SimilarProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  parentId?: String;
  parentId_not?: String;
  parentId_in?: String[] | String;
  parentId_not_in?: String[] | String;
  parentId_lt?: String;
  parentId_lte?: String;
  parentId_gt?: String;
  parentId_gte?: String;
  parentId_contains?: String;
  parentId_not_contains?: String;
  parentId_starts_with?: String;
  parentId_not_starts_with?: String;
  parentId_ends_with?: String;
  parentId_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  AND?: SimilarProductWhereInput[] | SimilarProductWhereInput;
  OR?: SimilarProductWhereInput[] | SimilarProductWhereInput;
  NOT?: SimilarProductWhereInput[] | SimilarProductWhereInput;
}

export interface ProductPageUpdateDataInput {
  url?: String;
  regex?: String;
}

export type SimilarProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  url?: String;
}>;

export interface fieldMetaDataUpdateInput {
  name?: String;
  foundIn?: fieldMetaDataUpdatefoundInInput;
  xhrMetaData?: XhrMetaDataUpdateOneInput;
  scriptMetaData?: ScriptMetaDataUpdateOneInput;
  htmlMetaData?: HtmlMetaDataUpdateOneInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface fieldMetaDataPreviousValuesNode {
  id: ID_Output;
  name: String;
  foundIn: DataSource[];
}

export interface fieldMetaDataPreviousValues
  extends Promise<fieldMetaDataPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  foundIn: () => Promise<DataSource[]>;
}

export interface fieldMetaDataPreviousValuesSubscription
  extends Promise<AsyncIterator<fieldMetaDataPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  foundIn: () => Promise<AsyncIterator<DataSource[]>>;
}

export interface AggregateProductObservationNode {
  count: Int;
}

export interface AggregateProductObservation
  extends Promise<AggregateProductObservationNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductObservationSubscription
  extends Promise<AsyncIterator<AggregateProductObservationNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductFetcherNode {
  id: ID_Output;
  generatedCode?: String;
  isCompleted?: Boolean;
}

export interface ProductFetcher
  extends Promise<ProductFetcherNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  generatedCode: () => Promise<String>;
  productObservation: <T = ProductObservation>() => T;
  isCompleted: () => Promise<Boolean>;
}

export interface ProductFetcherSubscription
  extends Promise<AsyncIterator<ProductFetcherNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  generatedCode: () => Promise<AsyncIterator<String>>;
  productObservation: <T = ProductObservationSubscription>() => T;
  isCompleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface ProductObservationEdgeNode {
  cursor: String;
}

export interface ProductObservationEdge
  extends Promise<ProductObservationEdgeNode>,
    Fragmentable {
  node: <T = ProductObservation>() => T;
  cursor: () => Promise<String>;
}

export interface ProductObservationEdgeSubscription
  extends Promise<AsyncIterator<ProductObservationEdgeNode>>,
    Fragmentable {
  node: <T = ProductObservationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductObservationNode {
  id: ID_Output;
  vimVersion?: String;
  schemaVersion?: String;
  parentId?: String;
  variantId?: String;
  imprint?: Boolean;
  title?: String;
  brand?: String;
  description?: String;
  extDescription?: String;
  imageUrlPrimary?: String;
  imageUrlSecondaries: String[];
  productDetails?: Json;
  productStates: ProductState[];
  ratingCount?: Int;
  ratingValue?: Int;
  keywords: String[];
  categories: String[];
  upc?: String;
  priceCurrent?: Float;
  priceList?: Float;
  currency?: String;
  inStock: Boolean;
  isCanoncial?: Boolean;
  canonicalUrl?: String;
  storeExtraInfo?: Json;
  quantityInStock?: Int;
  quantityRequired?: Int;
  quantityAllowed?: Int;
  quantityIncrement?: Int;
  finalSale?: Boolean;
  deals?: String;
}

export interface ProductObservation
  extends Promise<ProductObservationNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  vimVersion: () => Promise<String>;
  schemaVersion: () => Promise<String>;
  parentId: () => Promise<String>;
  variantId: () => Promise<String>;
  imprint: () => Promise<Boolean>;
  title: () => Promise<String>;
  brand: () => Promise<String>;
  description: () => Promise<String>;
  extDescription: () => Promise<String>;
  imageUrlPrimary: () => Promise<String>;
  imageUrlSecondaries: () => Promise<String[]>;
  productDetails: () => Promise<Json>;
  productStates: () => Promise<ProductState[]>;
  ratingCount: () => Promise<Int>;
  ratingValue: () => Promise<Int>;
  keywords: () => Promise<String[]>;
  categories: () => Promise<String[]>;
  upc: () => Promise<String>;
  priceCurrent: () => Promise<Float>;
  priceList: () => Promise<Float>;
  currency: () => Promise<String>;
  inStock: () => Promise<Boolean>;
  isCanoncial: () => Promise<Boolean>;
  canonicalUrl: () => Promise<String>;
  storeExtraInfo: () => Promise<Json>;
  relatedProducts: <T = FragmentableArray<RelatedProductNode>>(
    args?: {
      where?: RelatedProductWhereInput;
      orderBy?: RelatedProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  similarProducts: <T = FragmentableArray<SimilarProductNode>>(
    args?: {
      where?: SimilarProductWhereInput;
      orderBy?: SimilarProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  quantityInStock: () => Promise<Int>;
  quantityRequired: () => Promise<Int>;
  quantityAllowed: () => Promise<Int>;
  quantityIncrement: () => Promise<Int>;
  finalSale: () => Promise<Boolean>;
  deals: () => Promise<String>;
}

export interface ProductObservationSubscription
  extends Promise<AsyncIterator<ProductObservationNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  vimVersion: () => Promise<AsyncIterator<String>>;
  schemaVersion: () => Promise<AsyncIterator<String>>;
  parentId: () => Promise<AsyncIterator<String>>;
  variantId: () => Promise<AsyncIterator<String>>;
  imprint: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  extDescription: () => Promise<AsyncIterator<String>>;
  imageUrlPrimary: () => Promise<AsyncIterator<String>>;
  imageUrlSecondaries: () => Promise<AsyncIterator<String[]>>;
  productDetails: () => Promise<AsyncIterator<Json>>;
  productStates: () => Promise<AsyncIterator<ProductState[]>>;
  ratingCount: () => Promise<AsyncIterator<Int>>;
  ratingValue: () => Promise<AsyncIterator<Int>>;
  keywords: () => Promise<AsyncIterator<String[]>>;
  categories: () => Promise<AsyncIterator<String[]>>;
  upc: () => Promise<AsyncIterator<String>>;
  priceCurrent: () => Promise<AsyncIterator<Float>>;
  priceList: () => Promise<AsyncIterator<Float>>;
  currency: () => Promise<AsyncIterator<String>>;
  inStock: () => Promise<AsyncIterator<Boolean>>;
  isCanoncial: () => Promise<AsyncIterator<Boolean>>;
  canonicalUrl: () => Promise<AsyncIterator<String>>;
  storeExtraInfo: () => Promise<AsyncIterator<Json>>;
  relatedProducts: <T = Promise<AsyncIterator<RelatedProductSubscription>>>(
    args?: {
      where?: RelatedProductWhereInput;
      orderBy?: RelatedProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  similarProducts: <T = Promise<AsyncIterator<SimilarProductSubscription>>>(
    args?: {
      where?: SimilarProductWhereInput;
      orderBy?: SimilarProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  quantityInStock: () => Promise<AsyncIterator<Int>>;
  quantityRequired: () => Promise<AsyncIterator<Int>>;
  quantityAllowed: () => Promise<AsyncIterator<Int>>;
  quantityIncrement: () => Promise<AsyncIterator<Int>>;
  finalSale: () => Promise<AsyncIterator<Boolean>>;
  deals: () => Promise<AsyncIterator<String>>;
}

export interface ProductObservationConnectionNode {}

export interface ProductObservationConnection
  extends Promise<ProductObservationConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ProductObservationEdgeNode>>() => T;
  aggregate: <T = AggregateProductObservation>() => T;
}

export interface ProductObservationConnectionSubscription
  extends Promise<AsyncIterator<ProductObservationConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProductObservationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProductObservationSubscription>() => T;
}

export interface AggregatefieldMetaDataNode {
  count: Int;
}

export interface AggregatefieldMetaData
  extends Promise<AggregatefieldMetaDataNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatefieldMetaDataSubscription
  extends Promise<AsyncIterator<AggregatefieldMetaDataNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface fieldMetaDataConnectionNode {}

export interface fieldMetaDataConnection
  extends Promise<fieldMetaDataConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<fieldMetaDataEdgeNode>>() => T;
  aggregate: <T = AggregatefieldMetaData>() => T;
}

export interface fieldMetaDataConnectionSubscription
  extends Promise<AsyncIterator<fieldMetaDataConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<fieldMetaDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregatefieldMetaDataSubscription>() => T;
}

export interface HtmlMetaDataNode {
  id: ID_Output;
  cssSelector?: String;
  selectedValue?: String;
  cheerioExpression?: String;
  transformedValue?: String;
}

export interface HtmlMetaData extends Promise<HtmlMetaDataNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  cssSelector: () => Promise<String>;
  selectedValue: () => Promise<String>;
  cheerioExpression: () => Promise<String>;
  transformations: <T = FragmentableArray<TransformationNode>>(
    args?: {
      where?: TransformationWhereInput;
      orderBy?: TransformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transformedValue: () => Promise<String>;
}

export interface HtmlMetaDataSubscription
  extends Promise<AsyncIterator<HtmlMetaDataNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  cssSelector: () => Promise<AsyncIterator<String>>;
  selectedValue: () => Promise<AsyncIterator<String>>;
  cheerioExpression: () => Promise<AsyncIterator<String>>;
  transformations: <T = Promise<AsyncIterator<TransformationSubscription>>>(
    args?: {
      where?: TransformationWhereInput;
      orderBy?: TransformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transformedValue: () => Promise<AsyncIterator<String>>;
}

export interface fieldMetaDataNode {
  id: ID_Output;
  name: String;
  foundIn: DataSource[];
}

export interface fieldMetaData
  extends Promise<fieldMetaDataNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  foundIn: () => Promise<DataSource[]>;
  xhrMetaData: <T = XhrMetaData>() => T;
  scriptMetaData: <T = ScriptMetaData>() => T;
  htmlMetaData: <T = HtmlMetaData>() => T;
}

export interface fieldMetaDataSubscription
  extends Promise<AsyncIterator<fieldMetaDataNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  foundIn: () => Promise<AsyncIterator<DataSource[]>>;
  xhrMetaData: <T = XhrMetaDataSubscription>() => T;
  scriptMetaData: <T = ScriptMetaDataSubscription>() => T;
  htmlMetaData: <T = HtmlMetaDataSubscription>() => T;
}

export interface HtmlMetaDataSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface HtmlMetaDataSubscriptionPayload
  extends Promise<HtmlMetaDataSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HtmlMetaData>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HtmlMetaDataPreviousValues>() => T;
}

export interface HtmlMetaDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HtmlMetaDataSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HtmlMetaDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HtmlMetaDataPreviousValuesSubscription>() => T;
}

export interface XhrMetaDataEdgeNode {
  cursor: String;
}

export interface XhrMetaDataEdge
  extends Promise<XhrMetaDataEdgeNode>,
    Fragmentable {
  node: <T = XhrMetaData>() => T;
  cursor: () => Promise<String>;
}

export interface XhrMetaDataEdgeSubscription
  extends Promise<AsyncIterator<XhrMetaDataEdgeNode>>,
    Fragmentable {
  node: <T = XhrMetaDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface XhrMetaDataPreviousValuesNode {
  id: ID_Output;
  request?: Json;
  propertyPath?: String;
  transformedValue?: String;
}

export interface XhrMetaDataPreviousValues
  extends Promise<XhrMetaDataPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  request: () => Promise<Json>;
  propertyPath: () => Promise<String>;
  transformedValue: () => Promise<String>;
}

export interface XhrMetaDataPreviousValuesSubscription
  extends Promise<AsyncIterator<XhrMetaDataPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  request: () => Promise<AsyncIterator<Json>>;
  propertyPath: () => Promise<AsyncIterator<String>>;
  transformedValue: () => Promise<AsyncIterator<String>>;
}

export interface TransformationPreviousValuesNode {
  id: ID_Output;
  functionName: String;
}

export interface TransformationPreviousValues
  extends Promise<TransformationPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  functionName: () => Promise<String>;
}

export interface TransformationPreviousValuesSubscription
  extends Promise<AsyncIterator<TransformationPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  functionName: () => Promise<AsyncIterator<String>>;
}

export interface AggregateXhrMetaDataNode {
  count: Int;
}

export interface AggregateXhrMetaData
  extends Promise<AggregateXhrMetaDataNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateXhrMetaDataSubscription
  extends Promise<AsyncIterator<AggregateXhrMetaDataNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HtmlMetaDataPreviousValuesNode {
  id: ID_Output;
  cssSelector?: String;
  selectedValue?: String;
  cheerioExpression?: String;
  transformedValue?: String;
}

export interface HtmlMetaDataPreviousValues
  extends Promise<HtmlMetaDataPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  cssSelector: () => Promise<String>;
  selectedValue: () => Promise<String>;
  cheerioExpression: () => Promise<String>;
  transformedValue: () => Promise<String>;
}

export interface HtmlMetaDataPreviousValuesSubscription
  extends Promise<AsyncIterator<HtmlMetaDataPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  cssSelector: () => Promise<AsyncIterator<String>>;
  selectedValue: () => Promise<AsyncIterator<String>>;
  cheerioExpression: () => Promise<AsyncIterator<String>>;
  transformedValue: () => Promise<AsyncIterator<String>>;
}

export interface XhrMetaDataConnectionNode {}

export interface XhrMetaDataConnection
  extends Promise<XhrMetaDataConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<XhrMetaDataEdgeNode>>() => T;
  aggregate: <T = AggregateXhrMetaData>() => T;
}

export interface XhrMetaDataConnectionSubscription
  extends Promise<AsyncIterator<XhrMetaDataConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<XhrMetaDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateXhrMetaDataSubscription>() => T;
}

export interface TransformationEdgeNode {
  cursor: String;
}

export interface TransformationEdge
  extends Promise<TransformationEdgeNode>,
    Fragmentable {
  node: <T = Transformation>() => T;
  cursor: () => Promise<String>;
}

export interface TransformationEdgeSubscription
  extends Promise<AsyncIterator<TransformationEdgeNode>>,
    Fragmentable {
  node: <T = TransformationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface XhrMetaDataNode {
  id: ID_Output;
  request?: Json;
  propertyPath?: String;
  transformedValue?: String;
}

export interface XhrMetaData extends Promise<XhrMetaDataNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  request: () => Promise<Json>;
  propertyPath: () => Promise<String>;
  transformations: <T = FragmentableArray<TransformationNode>>(
    args?: {
      where?: TransformationWhereInput;
      orderBy?: TransformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transformedValue: () => Promise<String>;
}

export interface XhrMetaDataSubscription
  extends Promise<AsyncIterator<XhrMetaDataNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  request: () => Promise<AsyncIterator<Json>>;
  propertyPath: () => Promise<AsyncIterator<String>>;
  transformations: <T = Promise<AsyncIterator<TransformationSubscription>>>(
    args?: {
      where?: TransformationWhereInput;
      orderBy?: TransformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transformedValue: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStoreNode {
  count: Int;
}

export interface AggregateStore
  extends Promise<AggregateStoreNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStoreSubscription
  extends Promise<AsyncIterator<AggregateStoreNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateProductFetcherNode {
  count: Int;
}

export interface AggregateProductFetcher
  extends Promise<AggregateProductFetcherNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductFetcherSubscription
  extends Promise<AsyncIterator<AggregateProductFetcherNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StoreConnectionNode {}

export interface StoreConnection
  extends Promise<StoreConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<StoreEdgeNode>>() => T;
  aggregate: <T = AggregateStore>() => T;
}

export interface StoreConnectionSubscription
  extends Promise<AsyncIterator<StoreConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StoreEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStoreSubscription>() => T;
}

export interface ProductFetcherSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ProductFetcherSubscriptionPayload
  extends Promise<ProductFetcherSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductFetcher>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductFetcherPreviousValues>() => T;
}

export interface ProductFetcherSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductFetcherSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductFetcherSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductFetcherPreviousValuesSubscription>() => T;
}

export interface StoreNode {
  id: ID_Output;
  storeId: String;
}

export interface Store extends Promise<StoreNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  storeId: () => Promise<String>;
  productFetcher: <T = ProductFetcher>() => T;
  productPages: <T = FragmentableArray<ProductPageNode>>(
    args?: {
      where?: ProductPageWhereInput;
      orderBy?: ProductPageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StoreSubscription
  extends Promise<AsyncIterator<StoreNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  storeId: () => Promise<AsyncIterator<String>>;
  productFetcher: <T = ProductFetcherSubscription>() => T;
  productPages: <T = Promise<AsyncIterator<ProductPageSubscription>>>(
    args?: {
      where?: ProductPageWhereInput;
      orderBy?: ProductPageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProductFetcherPreviousValuesNode {
  id: ID_Output;
  generatedCode?: String;
  isCompleted?: Boolean;
}

export interface ProductFetcherPreviousValues
  extends Promise<ProductFetcherPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  generatedCode: () => Promise<String>;
  isCompleted: () => Promise<Boolean>;
}

export interface ProductFetcherPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductFetcherPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  generatedCode: () => Promise<AsyncIterator<String>>;
  isCompleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface SimilarProductEdgeNode {
  cursor: String;
}

export interface SimilarProductEdge
  extends Promise<SimilarProductEdgeNode>,
    Fragmentable {
  node: <T = SimilarProduct>() => T;
  cursor: () => Promise<String>;
}

export interface SimilarProductEdgeSubscription
  extends Promise<AsyncIterator<SimilarProductEdgeNode>>,
    Fragmentable {
  node: <T = SimilarProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductFetcherEdgeNode {
  cursor: String;
}

export interface ProductFetcherEdge
  extends Promise<ProductFetcherEdgeNode>,
    Fragmentable {
  node: <T = ProductFetcher>() => T;
  cursor: () => Promise<String>;
}

export interface ProductFetcherEdgeSubscription
  extends Promise<AsyncIterator<ProductFetcherEdgeNode>>,
    Fragmentable {
  node: <T = ProductFetcherSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateScriptMetaDataNode {
  count: Int;
}

export interface AggregateScriptMetaData
  extends Promise<AggregateScriptMetaDataNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScriptMetaDataSubscription
  extends Promise<AsyncIterator<AggregateScriptMetaDataNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductObservationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ProductObservationSubscriptionPayload
  extends Promise<ProductObservationSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductObservation>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductObservationPreviousValues>() => T;
}

export interface ProductObservationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductObservationSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductObservationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductObservationPreviousValuesSubscription>() => T;
}

export interface ScriptMetaDataConnectionNode {}

export interface ScriptMetaDataConnection
  extends Promise<ScriptMetaDataConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ScriptMetaDataEdgeNode>>() => T;
  aggregate: <T = AggregateScriptMetaData>() => T;
}

export interface ScriptMetaDataConnectionSubscription
  extends Promise<AsyncIterator<ScriptMetaDataConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScriptMetaDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScriptMetaDataSubscription>() => T;
}

export interface ProductObservationPreviousValuesNode {
  id: ID_Output;
  vimVersion?: String;
  schemaVersion?: String;
  parentId?: String;
  variantId?: String;
  imprint?: Boolean;
  title?: String;
  brand?: String;
  description?: String;
  extDescription?: String;
  imageUrlPrimary?: String;
  imageUrlSecondaries: String[];
  productDetails?: Json;
  productStates: ProductState[];
  ratingCount?: Int;
  ratingValue?: Int;
  keywords: String[];
  categories: String[];
  upc?: String;
  priceCurrent?: Float;
  priceList?: Float;
  currency?: String;
  inStock: Boolean;
  isCanoncial?: Boolean;
  canonicalUrl?: String;
  storeExtraInfo?: Json;
  quantityInStock?: Int;
  quantityRequired?: Int;
  quantityAllowed?: Int;
  quantityIncrement?: Int;
  finalSale?: Boolean;
  deals?: String;
}

export interface ProductObservationPreviousValues
  extends Promise<ProductObservationPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  vimVersion: () => Promise<String>;
  schemaVersion: () => Promise<String>;
  parentId: () => Promise<String>;
  variantId: () => Promise<String>;
  imprint: () => Promise<Boolean>;
  title: () => Promise<String>;
  brand: () => Promise<String>;
  description: () => Promise<String>;
  extDescription: () => Promise<String>;
  imageUrlPrimary: () => Promise<String>;
  imageUrlSecondaries: () => Promise<String[]>;
  productDetails: () => Promise<Json>;
  productStates: () => Promise<ProductState[]>;
  ratingCount: () => Promise<Int>;
  ratingValue: () => Promise<Int>;
  keywords: () => Promise<String[]>;
  categories: () => Promise<String[]>;
  upc: () => Promise<String>;
  priceCurrent: () => Promise<Float>;
  priceList: () => Promise<Float>;
  currency: () => Promise<String>;
  inStock: () => Promise<Boolean>;
  isCanoncial: () => Promise<Boolean>;
  canonicalUrl: () => Promise<String>;
  storeExtraInfo: () => Promise<Json>;
  quantityInStock: () => Promise<Int>;
  quantityRequired: () => Promise<Int>;
  quantityAllowed: () => Promise<Int>;
  quantityIncrement: () => Promise<Int>;
  finalSale: () => Promise<Boolean>;
  deals: () => Promise<String>;
}

export interface ProductObservationPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductObservationPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  vimVersion: () => Promise<AsyncIterator<String>>;
  schemaVersion: () => Promise<AsyncIterator<String>>;
  parentId: () => Promise<AsyncIterator<String>>;
  variantId: () => Promise<AsyncIterator<String>>;
  imprint: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  brand: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  extDescription: () => Promise<AsyncIterator<String>>;
  imageUrlPrimary: () => Promise<AsyncIterator<String>>;
  imageUrlSecondaries: () => Promise<AsyncIterator<String[]>>;
  productDetails: () => Promise<AsyncIterator<Json>>;
  productStates: () => Promise<AsyncIterator<ProductState[]>>;
  ratingCount: () => Promise<AsyncIterator<Int>>;
  ratingValue: () => Promise<AsyncIterator<Int>>;
  keywords: () => Promise<AsyncIterator<String[]>>;
  categories: () => Promise<AsyncIterator<String[]>>;
  upc: () => Promise<AsyncIterator<String>>;
  priceCurrent: () => Promise<AsyncIterator<Float>>;
  priceList: () => Promise<AsyncIterator<Float>>;
  currency: () => Promise<AsyncIterator<String>>;
  inStock: () => Promise<AsyncIterator<Boolean>>;
  isCanoncial: () => Promise<AsyncIterator<Boolean>>;
  canonicalUrl: () => Promise<AsyncIterator<String>>;
  storeExtraInfo: () => Promise<AsyncIterator<Json>>;
  quantityInStock: () => Promise<AsyncIterator<Int>>;
  quantityRequired: () => Promise<AsyncIterator<Int>>;
  quantityAllowed: () => Promise<AsyncIterator<Int>>;
  quantityIncrement: () => Promise<AsyncIterator<Int>>;
  finalSale: () => Promise<AsyncIterator<Boolean>>;
  deals: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRelatedProductNode {
  count: Int;
}

export interface AggregateRelatedProduct
  extends Promise<AggregateRelatedProductNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRelatedProductSubscription
  extends Promise<AsyncIterator<AggregateRelatedProductNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductFetcherConnectionNode {}

export interface ProductFetcherConnection
  extends Promise<ProductFetcherConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ProductFetcherEdgeNode>>() => T;
  aggregate: <T = AggregateProductFetcher>() => T;
}

export interface ProductFetcherConnectionSubscription
  extends Promise<AsyncIterator<ProductFetcherConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductFetcherEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductFetcherSubscription>() => T;
}

export interface RelatedProductConnectionNode {}

export interface RelatedProductConnection
  extends Promise<RelatedProductConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<RelatedProductEdgeNode>>() => T;
  aggregate: <T = AggregateRelatedProduct>() => T;
}

export interface RelatedProductConnectionSubscription
  extends Promise<AsyncIterator<RelatedProductConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RelatedProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRelatedProductSubscription>() => T;
}

export interface ProductPageSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ProductPageSubscriptionPayload
  extends Promise<ProductPageSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPage>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPagePreviousValues>() => T;
}

export interface ProductPageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductPageSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductPageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPagePreviousValuesSubscription>() => T;
}

export interface ProductPageEdgeNode {
  cursor: String;
}

export interface ProductPageEdge
  extends Promise<ProductPageEdgeNode>,
    Fragmentable {
  node: <T = ProductPage>() => T;
  cursor: () => Promise<String>;
}

export interface ProductPageEdgeSubscription
  extends Promise<AsyncIterator<ProductPageEdgeNode>>,
    Fragmentable {
  node: <T = ProductPageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductPagePreviousValuesNode {
  id: ID_Output;
  url: String;
  regex?: String;
}

export interface ProductPagePreviousValues
  extends Promise<ProductPagePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  regex: () => Promise<String>;
}

export interface ProductPagePreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPagePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  regex: () => Promise<AsyncIterator<String>>;
}

export interface HtmlMetaDataConnectionNode {}

export interface HtmlMetaDataConnection
  extends Promise<HtmlMetaDataConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<HtmlMetaDataEdgeNode>>() => T;
  aggregate: <T = AggregateHtmlMetaData>() => T;
}

export interface HtmlMetaDataConnectionSubscription
  extends Promise<AsyncIterator<HtmlMetaDataConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HtmlMetaDataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHtmlMetaDataSubscription>() => T;
}

export interface XhrMetaDataSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface XhrMetaDataSubscriptionPayload
  extends Promise<XhrMetaDataSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = XhrMetaData>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = XhrMetaDataPreviousValues>() => T;
}

export interface XhrMetaDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<XhrMetaDataSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = XhrMetaDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = XhrMetaDataPreviousValuesSubscription>() => T;
}

export interface fieldMetaDataSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface fieldMetaDataSubscriptionPayload
  extends Promise<fieldMetaDataSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = fieldMetaData>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = fieldMetaDataPreviousValues>() => T;
}

export interface fieldMetaDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<fieldMetaDataSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = fieldMetaDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = fieldMetaDataPreviousValuesSubscription>() => T;
}

export interface RelatedProductSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RelatedProductSubscriptionPayload
  extends Promise<RelatedProductSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RelatedProduct>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RelatedProductPreviousValues>() => T;
}

export interface RelatedProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RelatedProductSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RelatedProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RelatedProductPreviousValuesSubscription>() => T;
}

export interface fieldMetaDataEdgeNode {
  cursor: String;
}

export interface fieldMetaDataEdge
  extends Promise<fieldMetaDataEdgeNode>,
    Fragmentable {
  node: <T = fieldMetaData>() => T;
  cursor: () => Promise<String>;
}

export interface fieldMetaDataEdgeSubscription
  extends Promise<AsyncIterator<fieldMetaDataEdgeNode>>,
    Fragmentable {
  node: <T = fieldMetaDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RelatedProductPreviousValuesNode {
  id: ID_Output;
  parentId?: String;
  url?: String;
}

export interface RelatedProductPreviousValues
  extends Promise<RelatedProductPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parentId: () => Promise<String>;
  url: () => Promise<String>;
}

export interface RelatedProductPreviousValuesSubscription
  extends Promise<AsyncIterator<RelatedProductPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parentId: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface TransformationConnectionNode {}

export interface TransformationConnection
  extends Promise<TransformationConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<TransformationEdgeNode>>() => T;
  aggregate: <T = AggregateTransformation>() => T;
}

export interface TransformationConnectionSubscription
  extends Promise<AsyncIterator<TransformationConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransformationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransformationSubscription>() => T;
}

export interface SimilarProductNode {
  id: ID_Output;
  parentId?: String;
  url?: String;
}

export interface SimilarProduct
  extends Promise<SimilarProductNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parentId: () => Promise<String>;
  url: () => Promise<String>;
}

export interface SimilarProductSubscription
  extends Promise<AsyncIterator<SimilarProductNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parentId: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface TransformationNode {
  id: ID_Output;
  functionName: String;
}

export interface Transformation
  extends Promise<TransformationNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  functionName: () => Promise<String>;
}

export interface TransformationSubscription
  extends Promise<AsyncIterator<TransformationNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  functionName: () => Promise<AsyncIterator<String>>;
}

export interface ScriptMetaDataSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScriptMetaDataSubscriptionPayload
  extends Promise<ScriptMetaDataSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScriptMetaData>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScriptMetaDataPreviousValues>() => T;
}

export interface ScriptMetaDataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScriptMetaDataSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScriptMetaDataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScriptMetaDataPreviousValuesSubscription>() => T;
}

export interface SimilarProductConnectionNode {}

export interface SimilarProductConnection
  extends Promise<SimilarProductConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<SimilarProductEdgeNode>>() => T;
  aggregate: <T = AggregateSimilarProduct>() => T;
}

export interface SimilarProductConnectionSubscription
  extends Promise<AsyncIterator<SimilarProductConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SimilarProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSimilarProductSubscription>() => T;
}

export interface ScriptMetaDataPreviousValuesNode {
  id: ID_Output;
  script?: Json;
  regex?: String;
  propertyPath?: String;
  transformedValue?: String;
}

export interface ScriptMetaDataPreviousValues
  extends Promise<ScriptMetaDataPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  script: () => Promise<Json>;
  regex: () => Promise<String>;
  propertyPath: () => Promise<String>;
  transformedValue: () => Promise<String>;
}

export interface ScriptMetaDataPreviousValuesSubscription
  extends Promise<AsyncIterator<ScriptMetaDataPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  script: () => Promise<AsyncIterator<Json>>;
  regex: () => Promise<AsyncIterator<String>>;
  propertyPath: () => Promise<AsyncIterator<String>>;
  transformedValue: () => Promise<AsyncIterator<String>>;
}

export interface ScriptMetaDataNode {
  id: ID_Output;
  script?: Json;
  regex?: String;
  propertyPath?: String;
  transformedValue?: String;
}

export interface ScriptMetaData
  extends Promise<ScriptMetaDataNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  script: () => Promise<Json>;
  regex: () => Promise<String>;
  propertyPath: () => Promise<String>;
  transformations: <T = FragmentableArray<TransformationNode>>(
    args?: {
      where?: TransformationWhereInput;
      orderBy?: TransformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transformedValue: () => Promise<String>;
}

export interface ScriptMetaDataSubscription
  extends Promise<AsyncIterator<ScriptMetaDataNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  script: () => Promise<AsyncIterator<Json>>;
  regex: () => Promise<AsyncIterator<String>>;
  propertyPath: () => Promise<AsyncIterator<String>>;
  transformations: <T = Promise<AsyncIterator<TransformationSubscription>>>(
    args?: {
      where?: TransformationWhereInput;
      orderBy?: TransformationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transformedValue: () => Promise<AsyncIterator<String>>;
}

export interface HtmlMetaDataEdgeNode {
  cursor: String;
}

export interface HtmlMetaDataEdge
  extends Promise<HtmlMetaDataEdgeNode>,
    Fragmentable {
  node: <T = HtmlMetaData>() => T;
  cursor: () => Promise<String>;
}

export interface HtmlMetaDataEdgeSubscription
  extends Promise<AsyncIterator<HtmlMetaDataEdgeNode>>,
    Fragmentable {
  node: <T = HtmlMetaDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductPageNode {
  count: Int;
}

export interface AggregateProductPage
  extends Promise<AggregateProductPageNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductPageSubscription
  extends Promise<AsyncIterator<AggregateProductPageNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SimilarProductSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SimilarProductSubscriptionPayload
  extends Promise<SimilarProductSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SimilarProduct>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SimilarProductPreviousValues>() => T;
}

export interface SimilarProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SimilarProductSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SimilarProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SimilarProductPreviousValuesSubscription>() => T;
}

export interface ProductPageNode {
  id: ID_Output;
  url: String;
  regex?: String;
}

export interface ProductPage extends Promise<ProductPageNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  regex: () => Promise<String>;
}

export interface ProductPageSubscription
  extends Promise<AsyncIterator<ProductPageNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  regex: () => Promise<AsyncIterator<String>>;
}

export interface SimilarProductPreviousValuesNode {
  id: ID_Output;
  parentId?: String;
  url?: String;
}

export interface SimilarProductPreviousValues
  extends Promise<SimilarProductPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parentId: () => Promise<String>;
  url: () => Promise<String>;
}

export interface SimilarProductPreviousValuesSubscription
  extends Promise<AsyncIterator<SimilarProductPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parentId: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransformationNode {
  count: Int;
}

export interface AggregateTransformation
  extends Promise<AggregateTransformationNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransformationSubscription
  extends Promise<AsyncIterator<AggregateTransformationNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RelatedProductNode {
  id: ID_Output;
  parentId?: String;
  url?: String;
}

export interface RelatedProduct
  extends Promise<RelatedProductNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parentId: () => Promise<String>;
  url: () => Promise<String>;
}

export interface RelatedProductSubscription
  extends Promise<AsyncIterator<RelatedProductNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parentId: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSimilarProductNode {
  count: Int;
}

export interface AggregateSimilarProduct
  extends Promise<AggregateSimilarProductNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSimilarProductSubscription
  extends Promise<AsyncIterator<AggregateSimilarProductNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RelatedProductEdgeNode {
  cursor: String;
}

export interface RelatedProductEdge
  extends Promise<RelatedProductEdgeNode>,
    Fragmentable {
  node: <T = RelatedProduct>() => T;
  cursor: () => Promise<String>;
}

export interface RelatedProductEdgeSubscription
  extends Promise<AsyncIterator<RelatedProductEdgeNode>>,
    Fragmentable {
  node: <T = RelatedProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TransformationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TransformationSubscriptionPayload
  extends Promise<TransformationSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Transformation>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransformationPreviousValues>() => T;
}

export interface TransformationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransformationSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransformationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransformationPreviousValuesSubscription>() => T;
}

export interface AggregateHtmlMetaDataNode {
  count: Int;
}

export interface AggregateHtmlMetaData
  extends Promise<AggregateHtmlMetaDataNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHtmlMetaDataSubscription
  extends Promise<AsyncIterator<AggregateHtmlMetaDataNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StorePreviousValuesNode {
  id: ID_Output;
  storeId: String;
}

export interface StorePreviousValues
  extends Promise<StorePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  storeId: () => Promise<String>;
}

export interface StorePreviousValuesSubscription
  extends Promise<AsyncIterator<StorePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  storeId: () => Promise<AsyncIterator<String>>;
}

export interface StoreSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface StoreSubscriptionPayload
  extends Promise<StoreSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Store>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StorePreviousValues>() => T;
}

export interface StoreSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StoreSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StoreSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StorePreviousValuesSubscription>() => T;
}

export interface ProductPageConnectionNode {}

export interface ProductPageConnection
  extends Promise<ProductPageConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ProductPageEdgeNode>>() => T;
  aggregate: <T = AggregateProductPage>() => T;
}

export interface ProductPageConnectionSubscription
  extends Promise<AsyncIterator<ProductPageConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductPageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductPageSubscription>() => T;
}

export interface ScriptMetaDataEdgeNode {
  cursor: String;
}

export interface ScriptMetaDataEdge
  extends Promise<ScriptMetaDataEdgeNode>,
    Fragmentable {
  node: <T = ScriptMetaData>() => T;
  cursor: () => Promise<String>;
}

export interface ScriptMetaDataEdgeSubscription
  extends Promise<AsyncIterator<ScriptMetaDataEdgeNode>>,
    Fragmentable {
  node: <T = ScriptMetaDataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StoreEdgeNode {
  cursor: String;
}

export interface StoreEdge extends Promise<StoreEdgeNode>, Fragmentable {
  node: <T = Store>() => T;
  cursor: () => Promise<String>;
}

export interface StoreEdgeSubscription
  extends Promise<AsyncIterator<StoreEdgeNode>>,
    Fragmentable {
  node: <T = StoreSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Json = any;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/**
 * Type Defs
 */

export const prisma: Prisma;
